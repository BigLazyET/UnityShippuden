

命令模式：
1.首先思考一种情况
游戏中需要接收用户输入(Input)并做出相应的响应(Action)
我们可以规定死：用户按下"w"，执行forward()，代表前进；按下"a"，执行left()，代表向左走，如此类推
那么当用户想自定义输入与响应行为的映射呢？，例如，用户想定义成：按下"w"，执行back()后退。
2.针对上面情况的思考，我们如何支持用户自定义配置呢？当然方法应该有很多，其中一种方法可以用命令模式来解决这种需求。
既然一开始按下"w"，执行的是forward()，后来要按下"w"，执行的是back()，那么显而易见，按下"w"这个操作是不变的，相应的响应action在不断改变，衍生来说就是可以被更换，像积木一样。
提到可以更换的东西，就要想到基类，接口，抽象等等多态要素
3.针对上面的总结，那么我就把forward(),left()这一类的action行为抽象出一个类出来，就叫Action类
public abstract class Action : ScriptableObject { public abstract void Act(); }
4.接着3的工作，我们就可以为具体的行为Action进行编程了，只要继承下Action即可，并实现各自的Act方法
5.好了，接下来在Input方法中，有几个Input输入行为，定义几个Action字段action，然后在各自的input判断中调用action.Act()

好了，上面写完，细想开来等于没说：没解决任何事情嘛，跟简单粗暴地根据Input调用相应的forward()和left()等方法有啥不一样呢，只不过中间加了一层Action抽象层而已，然并卵。还多些了这么多代码，定义了这么多Action子类。
多态虽然是多态，但是在最终调用action.Act()的时候，action肯定要定性为具体哪个Action子类的。
用户原来按住"w"向前走的，现在想换个映射，按住"w"，向后走，怎么实现呢？


第一阶段：符合常规思考逻辑
1.根据用户Input的输入：比如检测到Input.getButton("W")
2.执行对应的操作Action：比如前进，do forward...
弊端：各个状态之间没有约束，随意切换，造成混乱。比如人有蹲下，站立，跳起的状态，按下S键，蹲下；按下W键，跳起；松开S，站立。由此可见，蹲下是不能直接切换到跳起状态的，虽然代码不会报错，但是画面和动画会有意想不到的变化

第二阶段：优化，优化啥呢，那就优化状态吧...
引入有效状态机：1.规定玩家状态总数是有限的   2.规定状态之间的切换规则，不存在越级切换
那么优化之后的逻辑：
1.先获取玩家当前的状态
2.根据状态，选择具体状态类去做处理
3.在具体状态类逻辑中，只针对当前状态能切换到下一状态的这一逻辑的必要条件：用户按了哪些键，才执行切换操作（这一过程就过滤掉了很多无用的判断input类型的代码）
4.根据用户传入的input，在这个逻辑中运行，如果命中input类型，就执行状态切换，如果不命中就什么都不干。

第三阶段：第二阶段看起来已经很好了，但是我们想操作一扇门，一个窗户，一块石头呢？
我们当然可以针对门，窗户，石头再写一长串逻辑代码
但是我们可以看到，玩家，门，窗户，石头这些都是可操作对象，那么显而易见，我们可以对这些操作对象进行抽象。
这样代码就可以进行插拔了，对任何对象，甚至后期新加入的对象都可以进行操作。

第四阶段：第三阶段已经看起来完美了，但是我们要考虑到，以上都是基于用户操作的，也就是说基于Input的，但是关于敌人和BOSS的运动，并不是玩家操作的，而是AI操作的
好！那么我们可以针对操作者进行抽象
这样代码就可以进行彻底的插拔了。对任何操作者，对任何可操作对象，只要附加上对应的代码组件就行了。